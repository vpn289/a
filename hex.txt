0000  0001 0010 0100 1000 0011 0101 0110 1001 1010 1100
   0     1    2    4    8    3    5    6    9    A    C
1111  1110 1101 1011 0111 1100 1010 1001 0110 0101 0011    
   F     E    D    B    7    C    A    9    6    5    3

0  1 2 4 8   7 B D E  F 
0   1           3     4  ones


8 пикселов ака квази 9битных слов проверщаются в 9 выходных байт
0 байт сдвигаем на 0 бит
1 на 1
2- на 2
3 на 3
4-4,... 7-7, 8 на 8 - вот и появился 9-й байт

1000 0001 0 1000 0001 0 1000 0001 0 1000 0001 0 1000 0001 ъ
1000 0001
0 1000 000  1
кщк
10 1000 0001

ырд 

кодировщик
на входе 0003 0007 0102 0100 0103 0104 
используется только 9 бит

на выходе группы по 8 бит.

получилось. теперь цель собственно перекодировать обычные пикселы в LZW код


aaaaaaaaaaaa

aa -102
aaa-103
aaaa-104
...
255(a) -1ff 


LZW кодировщик

берем первый пиксел, выплевываем его
берем второй пиксел, записываем по индексу 102 строку первый-второй, выплевываем 102

12345123451122334455

12
23
123
34
234
1234
45
345
2345
12345

Устройство словаря
строки по 1 байт гранулярити
на начало каждой строки ссылка из 256 кворд таблицы
список индекс

выборка строки из входного потока
поиск строки в словаре
запись строки в словарь
вставка кода в выходной поток

выборка строки из входного потака
1) указатель на начало входного потока
2) указатель на текущий символ
все что между ними - искомая строка
такая полная строка никогда не находится изза того что она длиннее последней внесенной
предыдущая строка - строка, усеченная на символ с конца. ТО-есть 
3) указатель на хвост искомой строки.
искомая строка удлинняется только после того, как она была найдена в словаре.
