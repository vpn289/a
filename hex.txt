0000  0001 0010 0100 1000 0011 0101 0110 1001 1010 1100
   0     1    2    4    8    3    5    6    9    A    C
1111  1110 1101 1011 0111 1100 1010 1001 0110 0101 0011    
   F     E    D    B    7    C    A    9    6    5    3

0  1 2 4 8   7 B D E  F 
0   1           3     4  ones


8 пикселов ака квази 9битных слов проверщаются в 9 выходных байт
0 байт сдвигаем на 0 бит
1 на 1
2- на 2
3 на 3
4-4,... 7-7, 8 на 8 - вот и появился 9-й байт

1000 0001 0 1000 0001 0 1000 0001 0 1000 0001 0 1000 0001 ъ
1000 0001
0 1000 000  1
кщк
10 1000 0001

ырд 

кодировщик
на входе 0003 0007 0102 0100 0103 0104 
используется только 9 бит

на выходе группы по 8 бит.

получилось. теперь цель собственно перекодировать обычные пикселы в LZW код


aaaaaaaaaaaa

aa -102
aaa-103
aaaa-104
...
255(a) -1ff 





LZW кодировщик

берем первый пиксел, выплевываем его
берем второй пиксел, записываем по индексу 102 строку первый-второй, выплевываем 102

12345123451122334455

12
23
123
34
234
1234
45
345
2345
12345

Устройство словаря
строки по 1 байт гранулярити
на начало каждой строки ссылка из 256 кворд таблицы
список индекс
и вот тут поподробнее
первые 256 строк - однобайтные, потом двух и более. Для единообразия нужно делать одинаково. либо делать "универсальный заполнитель".
Пожалуй, начнем со второго. 


выборка строки из входного потока
поиск строки в словаре
запись строки в словарь
вставка кода в выходной поток

выборка строки из входного потака
1) указатель на начало входного потока
2) указатель на текущий символ
все что между ними - искомая строка
такая полная строка никогда не находится изза того что она длиннее последней внесенной
предыдущая строка - строка, усеченная на символ с конца. ТО-есть 
3) указатель на хвост искомой строки.
искомая строка удлинняется только после того, как она была найдена в словаре.

как собственно искать?
в рах записываем 8 байт
или нет
берем один байт...
сперва искомая строка двух байтная, ищем ее так:
если достигнут последний занятый код - хначит ее нет, надо добавить.
если найден, значит добавляем на первый свободный код новую строку.

берем первый байт искомой строки и идем по индексам-строкам ищем совпадение, нашлось - сравниваем следующий. 

И вот такая петрушка:
Сперва из пикселов делаем lzw код, а потом 9-8 пакуем его в файл.




lzw_table - таблица ссылок на строки в lzw_vocab

Начальное состояние
lzw_table:
dq 100
dq 101
dq 0
....
dq 0

При этом есть переменная lzw_table_last, которая указывает на lzw_table+8

             dq 100
lzw_table+8: dq 101
             dq 000
             ...
             dq 000

Поиск строки в таблице, когда она пуста
Выбираем значение из lzw_table_last, разымименовываем его и сравниваем со 101. Равно - закончили поиск, такой строки
нет в таблице и надо ее добавить.

Добавление строки
Есть переменная lzw_vocab_last, которая хранит первое свободное место в lzw_vocab.
Берем ее значение и по нему переписываем нашу строку. Это же значение записываем в lzw_table по значению lzw_table_last.
Добавляем 8 к lzw_table_last, записывем новое значение в lzw_vocab_last (это rdi после movsb)

Входной поток - байты по адресу pixels.
Выходной поток - слова (16 бит) по адресу lzw_code

Поиск строки 
сохраненный строки лежат в lzw_vocab. Но адреса для поиска строки  надо брать из lzw_table. Последнее значение которой
находится в lzw_table_last.

Напоролись на 101, вызываем add_lzw_string.
Коли так, на вывод ничего не выдаем, а переходим дальше и ищем уже три байта. Коль не найдем, значит выплюнем ссылку на два байта.

